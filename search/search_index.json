{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Trino Gateway is a load balancer, proxy server, and configurable routing  gateway for multiple Trino clusters.</p>"},{"location":"#use-cases-advantages-and-features","title":"Use cases, advantages, and features","text":"<ul> <li>Use of a single connections URL for client tool users with workload   distribution across multiple Trino clusters.</li> <li>Automatic routing of queries to dedicated Trino clusters for specific   workloads or specific queries and data sources.</li> <li>No-downtime upgrades for Trino clusters behind the Trino Gateway in a   blue/green model or canary deployment model.</li> <li>Transparent change of capacity of Trino clusters without user interruptions.</li> </ul>"},{"location":"#high-level-architecture","title":"High-level architecture","text":""},{"location":"#other-resources","title":"Other resources","text":"<ul> <li>Trino Gateway announcement blog post</li> <li>Trino Gateway - because one Trino cluster is not enough<ul> <li>Presented by Will Morrison and Manfred Moser at Open Source Data Summit   in October 2024</li> <li> Video recording</li> <li>Slide deck</li> </ul> </li> <li>Many clusters and only one gateway:<ul> <li>Project announcement and overview at Trino Summit 2023 with use cases    from Bloomberg and Naver</li> <li> Video recording</li> <li>Slide deck</li> </ul> </li> <li>Slide deck about Trino Gateway status   for Trino Contributor Congregation in June 2024</li> <li>Lyft blog post</li> <li>Pinterest blog post</li> <li>Zomato blog post</li> <li>Shopify blog post</li> </ul>"},{"location":"design/","title":"Design","text":"<p>There are two types of requests: one is a request to Trino Gateway, and the other is a request that needs to be forwarded to Trino.</p>"},{"location":"design/#request-forwarding","title":"Request forwarding","text":"<p>Trino Gateway forwards some pre-defined URIs automatically to Trino. You can configure additional URIs to forward with the <code>extraWhitelistPaths</code> configuration.</p> <p>In order to support additional URIs that are only known at runtime, the <code>RouterPreMatchContainerRequestFilter</code> is used to process every request before the actual resource matching occurs. If the requests URI matches, the request is forwarded to <code>RouteToBackendResource</code>.</p> <p>Flow of request forwarding:</p> <ol> <li>Determine to which Trino cluster a query should be routed to.</li> <li>Prepare a request to send to Trino by adding <code>Via</code> headers and <code>X-Forwarded</code>    headers. Most headers are forwarded to Trino unmodified.</li> <li>Some request URI require special handling. For example, a    request which submit a new query, Trino Gateway retrieves the queryId from the    response from Trino. Some requests to the web UI require setting a session    cookie to ensure OIDC works. These are done by chaining asynchronous    operations using <code>Future</code>.</li> <li>The execution of requests to Trino and the response to the client are handled    by <code>airlift.jaxrs.AsyncResponseHandler</code>.</li> </ol>"},{"location":"development/","title":"Development","text":""},{"location":"development/#build-requirements","title":"Build requirements","text":"<ul> <li>Mac OS X or Linux</li> <li>Java 22+, 64-bit</li> <li>Docker</li> </ul>"},{"location":"development/#running-trino-gateway-in-your-ide","title":"Running Trino Gateway in your IDE","text":"<p>The best way to run Trino Gateway for development is to run the <code>TrinoGatewayRunner</code> class. You need to run <code>io.trino.gateway.TrinoGatewayRunner.main()</code> method on your IDE or execute the following command:</p> <pre><code>./mvnw test-compile exec:java -pl gateway-ha -Dexec.classpathScope=test -Dexec.mainClass=\"io.trino.gateway.TrinoGatewayRunner\"\n</code></pre>"},{"location":"development/#build-and-run","title":"Build and run","text":""},{"location":"development/#locally","title":"Locally","text":"<p>This project requires Java 22. Note that higher version of Java have not been verified and may run into unexpected issues.</p> <p>Run <code>./mvnw clean install</code> to build <code>trino-gateway</code>. VM options required for compilation and testing are specified in <code>.mvn/jvm.config</code>.</p> <p>Edit the configuration file <code>gateway-ha-config.yml</code> in the <code>gateway-ha</code> folder and update the mysql db information.</p> <pre><code>cd gateway-ha/target/\njava -jar gateway-ha-{{VERSION}}-jar-with-dependencies.jar ../gateway-ha-config.yml\n</code></pre>"},{"location":"development/#in-docker","title":"In Docker","text":"<p>Follow the separate instructions for building the container and running Trino Gateway with docker compose from the <code>README.md</code> file in the <code>docker</code> folder.</p>"},{"location":"development/#contributing","title":"Contributing","text":"<p>Want to help build Trino Gateway? Check out our contributing documentation</p>"},{"location":"development/#maintainers","title":"Maintainers","text":"<p>The following Trino and Trino Gateway maintainers are involved in Trino Gateway, and can help with pull request reviews and merges.</p> <ul> <li> chaho12 - Jaeho Yoo</li> <li> ebyhr - Yuya Ebihara</li> <li> mosabua - Manfred Moser</li> <li> oneonestar - Star Poon</li> <li> vishalya - Vishal Jadhav</li> <li> wendigo - Mateusz Gajewski</li> <li> willmostly - Will Morrison</li> </ul>"},{"location":"development/#contributor-meetings","title":"Contributor meetings","text":"<p>Contributor meetings are open to anyone and held every two weeks. Meeting notes and other details are available on GitHub.</p>"},{"location":"development/#release-process","title":"Release process","text":"<p>A full release process consists a number of steps:</p> <p>Create a release notes pull request including the following changes:</p> <ul> <li>Add new release notes in <code>docs/release-notes.md</code>.</li> <li>Update <code>VERSION</code> in <code>docs/quickstart.md</code>.</li> <li>Update <code>appVersion</code> to new version and <code>version</code> to new version with <code>.0.0</code>   appended in <code>helm/trino-gateway/Chart.yaml</code>. For example, update to   <code>appVersion: \"10\"</code> and <code>version: \"10.0.0\"</code>. </li> </ul> <p>Organize review, approval, and merge for the PR.</p> <p>Pull the changes locally:</p> <pre><code>cd trino-gateway\ngit checkout main\ngit pull\n</code></pre> <p>Run a Maven release build:</p> <pre><code>./mvnw clean release:prepare release:perform\n</code></pre> <p>A successful release build performs the necessary commits, and pushes the binaries to Maven Central staging.</p> <p>Close and release the staging repository, and wait until the sync to Central is completed. Confirm the presence of the artifacts at https://repo.maven.apache.org/maven2/io/trino/gateway/gateway-ha/.</p> <p>Ensure that you are logged into Docker Hub  with suitable permissions, and run the container release script with the version  number that was just released,  for example <code>6</code>:</p> <pre><code>docker/release-docker.sh 6\n</code></pre> <p>Once completed, verify the availability at https://hub.docker.com/r/trinodb/trino-gateway.</p> <p>Announce the release on Trino Slack and LinkedIn.</p>"},{"location":"docs/","title":"Documentation development","text":"<p>The Trino Gateway documentation uses markdown source files, MkDocs with the  material theme for rendering, and GitHub pages for hosting.</p> <p>The following sections contain minimal helpful tips to get started. More  details are available in the following resources:</p> <ul> <li>Material for MkDocs website</li> <li>MkDocs website</li> </ul>"},{"location":"docs/#writing-documentation","title":"Writing documentation","text":"<p>Content is written as markdown files in the <code>docs</code> folder.</p> <p>Writing style guidelines are identical to the Trino documentation and  website.</p> <p>Refer to the  reference docs from Material for MkDocs for syntax information.  </p>"},{"location":"docs/#running-site-locally","title":"Running site locally","text":"<p>Install <code>python</code> and <code>pipx</code>, for example with brew.</p> <p>Install <code>mkdocs-material</code> and all required dependencies in the <code>mkdocs-material</code>  virtual environment for Python:</p> <pre><code>pipx install --include-deps mkdocs-material \n</code></pre> <p>Add plugins to the virtual environment:</p> <pre><code>pipx inject --include-deps mkdocs-material cairosvg\n</code></pre> <p>Start the local site in the project root folder:</p> <pre><code>cd trino-gateway\nmkdocs serve\n</code></pre> <p>Access the site in your browser at http://127.0.0.1:8000/</p> <p>Edit the site sources as desired and refresh pages as needed. Some changes  require a restart of mkdocs.</p> <p>Alternatively, use a container to run mkdocs and avoid the need to install  mkdocs-material and all dependencies locally.</p> <pre><code>docker run --rm -it -v ${PWD}:/docs -p8000:8000 squidfunk/mkdocs-material \n</code></pre>"},{"location":"docs/#configuring-mkdocs","title":"Configuring MKDocs","text":"<p>MkDocs is configured in <code>mkdocs.yml</code>. Refer to the source, the  Material for MkDocs website  and the MkDocs website for more information.</p>"},{"location":"gateway-api/","title":"Gateway API","text":""},{"location":"gateway-api/#add-or-update-a-backend","title":"Add or update a backend","text":"<pre><code>curl -X POST http://localhost:8080/entity?entityType=GATEWAY_BACKEND \\\n -d '{  \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\"\n    }'\n</code></pre> <p>If the backend URL is different from the <code>proxyTo</code> URL (for example if they are internal vs. external hostnames). You can use the optional <code>externalUrl</code> field to override the link in the Active Backends page.</p> <pre><code>curl -X POST http://localhost:8080/entity?entityType=GATEWAY_BACKEND \\\n -d '{  \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8084\"\n    }'\n</code></pre>"},{"location":"gateway-api/#get-all-backends","title":"Get all backends","text":"<p><code>curl -X GET http://localhost:8080/entity/GATEWAY_BACKEND</code> <pre><code>[\n    {\n        \"name\": \"trino-1\",\n        \"proxyTo\": \"http://localhost:8081\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8081\"\n    },\n    {\n        \"name\": \"trino-2\",\n        \"proxyTo\": \"http://localhost:8082\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8082\"\n    },\n    {\n        \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8084\"\n    }\n]\n</code></pre></p>"},{"location":"gateway-api/#delete-a-backend","title":"Delete a backend","text":"<pre><code>curl -X POST -d \"trino3\" http://localhost:8080/gateway/backend/modify/delete\n</code></pre>"},{"location":"gateway-api/#deactivate-a-backend","title":"Deactivate a backend","text":"<pre><code>curl -X POST http://localhost:8080/gateway/backend/deactivate/trino-2\n</code></pre>"},{"location":"gateway-api/#get-all-active-backends","title":"Get all active backends","text":"<pre><code>curl -X GET http://localhost:8080/gateway/backend/active\n</code></pre> <p>Will return a JSON array of active Trino cluster backends: <pre><code>[\n    {\n        \"name\": \"trino-1\",\n        \"proxyTo\": \"http://localhost:8081\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8081\"\n    }\n]\n</code></pre></p>"},{"location":"gateway-api/#activate-a-backend","title":"Activate a backend","text":"<pre><code>curl -X POST http://localhost:8080/gateway/backend/activate/trino-2\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Trino Gateway is distributed as an executable JAR file. The release notes contain links to download specific versions. Alternatively, you can look at the development instructions to build the JAR file or use the TrinoGatewayRunner for local testing. The quickstart guide contains instructions for running the application locally. </p> <p>Following are instructions for installing Trino Gateway for production environments.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>Consider the following requirements for your Trino Gateway installation.</p>"},{"location":"installation/#java","title":"Java","text":"<p>Trino Gateway requires a Java 22 runtime. Older versions of Java can not be used. Newer versions might work but are not tested.</p> <p>Verify the Java version on your system with <code>java -version</code>.</p>"},{"location":"installation/#operating-system","title":"Operating system","text":"<p>No specific operating system is required. All testing and development is performed with Linux and MacOS.</p>"},{"location":"installation/#processor-architecture","title":"Processor architecture","text":"<p>No specific processor architecture is required, as long as a suitable Java distribution is installed.  </p>"},{"location":"installation/#backend-database","title":"Backend database","text":"<p>Trino Gateway requires a MySQL or PostgreSQL database.</p> <p>Use the following scripts in the <code>gateway-ha/src/main/resources/</code> folder to initialize the database:</p> <ul> <li><code>gateway-ha-persistence-mysql.sql</code> for MySQL</li> <li><code>gateway-ha-persistence-postgres.sql</code> for PostgreSQL</li> </ul> <p>The files are also included in the JAR file.</p>"},{"location":"installation/#trino-clusters","title":"Trino clusters","text":"<p>The proxied Trino clusters behind the Trino Gateway must support the Trino JDBC driver and the Trino REST API for cluster and node health information. Typically, this means that Trino versions 354 and higher should work, however newer Trino versions are strongly recommended.</p> <p>Trino-derived projects and platforms may work if the Trino JDBC driver and the REST API are supported. For example, Starburst Galaxy and Starburst Enterprise are known to work. Trino deployments with the Helm chart and other means on various cloud platforms, such as Amazon EKS also work. However Amazon Athena does not work since it uses alternative, custom protocols and lacks the concept of individual clusters.</p>"},{"location":"installation/#trino-configuration","title":"Trino configuration","text":"<p>From a users perspective Trino Gateway acts as a transparent proxy for one  or more Trino clusters. The following Trino configuration tips should be  taken into account for all clusters behind the Trino Gateway.</p> <p>If all client and server communication is routed through Trino Gateway,  then process forwarded HTTP headers must be enabled:</p> <pre><code>http-server.process-forwarded=true\n</code></pre> <p>Without this setting, first requests go from the user to Trino Gateway and then to Trino correctly. However, the URL for subsequent next URIs for more results in a query provided by Trino is then using the local URL of the Trino cluster, and not the URL of the Trino Gateway. This circumvents the Trino Gateway for all these requests. In scenarios, where the local URL of the Trino cluster is private  to the Trino cluster on the network level, these following calls do not work at all for users.</p> <p>This setting is also required for Trino to authenticate in the case TLS is  terminated at the Trino Gateway. Normally it refuses to authenticate plain HTTP  requests, but if <code>http-server.process-forwarded=true</code> it authenticates over  HTTP if the request includes <code>X-Forwarded-Proto: HTTPS</code>.</p> <p>To prevent Trino Gateway from sending <code>X-Forwarded-*</code> headers, add the following configuration:</p> <pre><code>routing:\n  addXForwardedHeaders: false\n</code></pre> <p>Find more information in the related Trino documentation.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>After downloading or building the JAR, rename it to <code>gateway-ha.jar</code>, and place it in a directory with read and write access such as <code>/opt/trinogateway</code>.</p> <p>Copy the example config file <code>gateway-ha-config.yml</code> from the <code>gateway-ha/</code> directory into the same directory, and update the configuration as needed.</p> <p>Each component of the Trino Gateway has a corresponding node in the configuration YAML file.</p>"},{"location":"installation/#secrets-in-configuration-file","title":"Secrets in configuration file","text":"<p>Environment variables can be used as values in the configuration file. You can manually set an environment variable on the command line.</p> <pre><code>export DB_PASSWORD=my-super-secret-pwd\n</code></pre> <p>To use this variable in the configuration file, you reference it with the  syntax <code>${ENV:VARIABLE}</code>. For example:</p> <pre><code>dataStore:\n  jdbcUrl: jdbc:postgresql://localhost:5432/gateway\n  user: postgres\n  password: ${ENV:DB_PASSWORD}\n</code></pre>"},{"location":"installation/#configure-routing-rules","title":"Configure routing rules","text":"<p>Find more information in the routing rules documentation.</p>"},{"location":"installation/#configure-logging","title":"Configure logging  <p>To configure the logging level for various classes, specify the path to the  <code>log.properties</code> file by setting <code>log.levels-file</code> in <code>serverConfig</code>.</p> <p>For additional configurations, use the <code>log.*</code> properties from the  Trino logging properties documentation and specify the properties in <code>serverConfig</code>.</p>","text":""},{"location":"installation/#proxying-additional-paths","title":"Proxying additional paths <p>By default, Trino Gateway only proxies requests to paths starting with <code>/v1/statement</code>, <code>/v1/query</code>, <code>/ui</code>, <code>/v1/info</code>, <code>/v1/node</code>, <code>/ui/api/stats</code> and <code>/oauth</code>.</p> <p>If you want to proxy additional paths, you can add them by adding the <code>extraWhitelistPaths</code> node to your configuration YAML file. Trino Gateway takes regexes from <code>extraWhitelistPaths</code> and forwards only those requests with a URI that exactly match. Be sure to use single-quoted strings so that escaping is not required.</p> <pre><code>extraWhitelistPaths:\n  - '/ui/insights'\n  - '/api/v1/biac'\n  - '/api/v1/dataProduct'\n  - '/api/v1/dataproduct'\n  - '/api/v2/.*'\n  - '/ext/faster'\n</code></pre>","text":""},{"location":"installation/#configure-additional-v1statement-like-paths","title":"Configure additional v1/statement-like paths <p>The Trino client protocol specifies that queries are initiated by a POST to <code>v1/statement</code>.  The Trino Gateway incorporates this into its routing logic by extracting and recording the  query id from responses to such requests. If you use an experimental or commercial build of Trino that supports additional endpoints, you can cause Trino Gateway to treat them  equivalently to <code>/v1/statement</code> by adding them under the <code>additionalStatementPaths</code> configuration node. They must be absolute, and no path can be a prefix to any other path. The standard <code>/v1/statement</code> path is always included and does not need to be configured.  For example:</p> <pre><code>additionalStatementPaths:\n  - '/ui/api/insights/ide/statement'\n  - '/v2/statement'\n</code></pre>","text":""},{"location":"installation/#configure-behind-a-load-balancer","title":"Configure behind a load balancer","text":"<p>A possible deployment of Trino Gateway is to run multiple instances of Trino  Gateway behind another generic load balancer, such as a load balancer from  your cloud hosting provider. In this deployment you must configure the  <code>serverConfig</code> to include enabling process forwarded HTTP headers:</p> <pre><code>serverConfig:\n  http-server.process-forwarded: true\n</code></pre>"},{"location":"installation/#running-trino-gateway","title":"Running Trino Gateway","text":"<p>Start Trino Gateway with the following java command in the directory of the JAR and YAML files:</p> <pre><code>java -XX:MinRAMPercentage=50 -XX:MaxRAMPercentage=80 \\\n    -jar gateway-ha.jar gateway-config.yml\n</code></pre>"},{"location":"installation/#helm","title":"Helm <p>Helm manages the deployment of Kubernetes applications by templating Kubernetes resources with a set of Helm charts. The Trino Gateway Helm chart consists  of the following components:</p> <ul> <li>A <code>config</code> node for general configuration</li> <li><code>dataStoreSecret</code>, <code>backendStateSecret</code> and <code>authenticationSecret</code> for    providing sensitive configurations through Kubernetes secrets, </li> <li>Standard Helm options such as <code>replicaCount</code>, <code>resources</code> and <code>ingress</code>.</li> </ul> <p>The default <code>values.yaml</code> found in the <code>helm/trino-gateway</code> folder includes basic configuration options as an example. For a simple deployment, proceed with  the following steps:</p> <p>Create a yaml file containing the configuration for your <code>datastore</code>:</p> <p><pre><code>cat &lt;&lt; EOF &gt; datastore.yaml\ndataStore:\n   jdbcUrl: jdbc:postgresql://yourdatabasehost:5432/gateway\n   user: postgres\n   password: secretpassword\n   driver: org.postgresql.Driver\nEOF\n</code></pre> Create a Kubernetes secret from this file:</p> <pre><code>kubectl create secret generic datastore-yaml --from-file datastore.yaml --dry-run=client -o yaml | kubectl apply -f -\n</code></pre> <p>Create a values override with a name such as <code>values-override.yaml</code> and reference this secret in the <code>backendStateSecret</code> node:</p> <pre><code>backendStateSecret:\n    name: \"datastore-yaml\"\n    key: \"datastore.yaml\"\n</code></pre> <p>When a Secret is created with the <code>--from-file</code> option, the filename is used as the key. Finally, you can deploy Trino Gateway with the chart from the root  of this repository:</p> <pre><code>helm install tg --values values-override.yaml helm/trino-gateway \n</code></pre> <p>Secrets for <code>authenticationSecret</code> and <code>backendState</code> can be provisioned similarly. Alternatively,  you can directly define the <code>config.backEndState</code>  node in <code>values-override.yaml</code> and leave <code>backendStateSecret</code> undefined.  However, a Secret is recommended to protect the  database credentials required for this  configuration.</p>","text":""},{"location":"installation/#additional-options","title":"Additional options","text":"<p>To implement routing rules, create a ConfigMap from your routing rules yaml definition:</p> <pre><code>kubectl create cm routing-rules --from-file your-routing-rules.yaml\n</code></pre> <p>Then mount it to your container:</p> <pre><code>volumes:\n    - name: routing-rules\n      configMap:\n          name: routing-rules\n          items:\n              name: your-routing-rules.yaml\n              path: your-routing-rules.yaml\n\nvolumeMounts:\n    - name: routing-rules\n      mountPath: \"/etc/routing-rules/your-routing-rules.yaml\"\n      subPath: your-routing-rules.yaml\n</code></pre> <p>Ensure that the <code>mountPath</code> matches the <code>rulesConfigPath</code> specified in your configuration. Note that the <code>subPath</code> is not strictly necessary, and if it  is not specified the file is mounted at <code>mountPath/&lt;configMap key&gt;</code>.  Kubernetes updates the mounted file when the ConfigMap is updated.</p> <p>Standard Helm options such as <code>replicaCount</code>, <code>image</code>, <code>imagePullSecrets</code>,  <code>service</code>, <code>ingress</code> and <code>resources</code> are supported. These are defined in  <code>helm/values.yaml</code>. </p>"},{"location":"installation/#health-checks","title":"Health Checks <p>Trino Gateway checks the health of each backend and deactivates it if  unhealthy. A backend that fails a health check must be manually reset to  active. Automatic recovery is not supported.</p> <p>The type of health check is configured by setting</p> <pre><code>clusterStatsConfiguration:\n  monitorType: \"\"\n</code></pre> <p>to one of the following values.</p>","text":""},{"location":"installation/#info_api-default","title":"INFO_API (default)","text":"<p>By default Trino Gateway uses the <code>v1/info</code> REST endpoint. A successful check is defined as a 200 response with <code>starting: false</code>. Connection timeout parameters  can be defined through the <code>monitor</code> node, for example</p> <pre><code>monitor:\n  connectTimeoutSeconds: 5\n  requestTimeoutSeconds: 10\n  idleTimeoutSeconds: 1\n  retries: 1\n</code></pre> <p>All timeout parameters are optional.</p>"},{"location":"installation/#jdbc","title":"JDBC","text":"<p>This uses a JDBC connection to query <code>system.runtime</code> tables for cluster  information. It is required for the query count based routing strategy. This is recommended over <code>UI_API</code> since it does not restrict the Web UI authentication method of backend clusters. Configure a username and password by adding <code>backendState</code> to your configuration. The username and password must be valid  across all backends.</p> <pre><code>backendState:\n  username: \"user\"\n  password: \"password\"\n</code></pre> <p>The request timeout can be set through</p> <pre><code>monitor:\n  requestTimeoutSeconds: 10\n</code></pre> <p>Other timeout parameters are not applicable to the JDBC connection.</p>"},{"location":"installation/#ui_api","title":"UI_API","text":"<p>This pulls cluster information from the <code>ui/api/stats</code> REST endpoint. This is supported for legacy reasons and may be deprecated in the future. It is only  supported for backend clusters with <code>web-ui.authentication.type=FORM</code>. Set a username and password using <code>backendState</code> as with the <code>JDBC</code> option.</p>"},{"location":"installation/#noop","title":"NOOP","text":"<p>This option disables health checks.</p>"},{"location":"migration-to-airlift/","title":"Migration to Airlift","text":"<p>The codebase of Trino Gateway has been heavily upgraded to meet the Trino standards. Dropwizard and Jetty Proxy has been replaced by Airbase and Airlift. This page documents the incompatible changes and aims to smooth the migration. The migration is only required for user using Trino Gateway before version 10.</p>"},{"location":"migration-to-airlift/#change-of-endpoints","title":"Change of endpoints","text":"<p>You have to make the following adjustments to take the change to using only one HTTP port into account.</p>"},{"location":"migration-to-airlift/#merge-of-service-ports","title":"Merge of service ports","text":"<p>Multiple service ports have been merged together. The old version listens to multiple ports: request service at port 9080, application service at port 9081, and the Admin service at port 9082. The new version only listens to one single port at 8080 by default.</p>"},{"location":"migration-to-airlift/#merge-of-request-service-and-application-service","title":"Merge of request service and application service","text":"<p>Requests to the Trino Gateway (Web UI and RESTful API) and requests that need to be forwarded to Trino are both served by the same port. The destination is determined by the HTTP URI in the request.</p>"},{"location":"migration-to-airlift/#removal-of-the-dropwizard-admin-service-at-port-9082","title":"Removal of the Dropwizard admin service at port 9082","text":"<p>The admin console page provided by Dropwizard (port 9082) has been removed. JMX can be viewed at <code>/v1/jmx</code>. There are no plans to support other functions on the Dropwizard Admin page (metrics, ping, threads, healthcheck, CPU profile, and CPU contention).</p>"},{"location":"migration-to-airlift/#path-change-for-webui","title":"Path change for WebUI","text":"<p>The root path for Trino Gateway WebUI has been changed from <code>/</code> to <code>/trino-gateway</code>. By default, access to <code>/</code> is redirected to <code>/trino-gateway</code>. This behavior can be changed by adding <code>/</code> to <code>extraWhitelistPaths</code>, which results in routing <code>/</code> to Trino.</p>"},{"location":"migration-to-airlift/#change-of-configuration","title":"Change of configuration","text":"<p>You must adjust your configuration to the following changes.</p>"},{"location":"migration-to-airlift/#change-of-service-ports","title":"Change of service ports","text":"<p><code>requestRouter</code>, <code>server</code>, <code>applicationConnectors</code>, and <code>adminConnectors</code> are replaced by <code>serverConfig</code>.</p> <p>Old config: <pre><code>requestRouter:\n    port: 8080\n    name: trinoRouter\n    historySize: 1000\n    requestBufferSize: 8192\nserver:\n    applicationConnectors:\n        - type: http\n          port: 8090\n          useForwardedHeaders: true\n    adminConnectors:\n        - type: http\n          port: 8091\n          useForwardedHeaders: true\n</code></pre></p> <p>New config: <pre><code>serverConfig:\n    node.environment: test\n    http-server.http.port: 8443\n    proxy.http-client.request-buffer-size: 8kB\n</code></pre></p>"},{"location":"migration-to-airlift/#tls-configuration","title":"TLS configuration","text":"<p><code>ssl</code>, <code>keystorePath</code>, and <code>keystorePass</code> are replaced by <code>http-server.https.*</code>. For more details, see Security</p> <p>Old config: <pre><code>requestRouter:\n  ssl: true\n  port: 8080\n  name: trinoRouter\n  historySize: 1000\n  keystorePath: &lt;path&gt;\n  keystorePass: &lt;password&gt;\n\nserver:\n  applicationConnectors:\n    - type: https\n      port: 8090\n      keyStorePath: &lt;path&gt;\n      keyStorePassword: &lt;password&gt;\n      useForwardedHeaders: true\n  adminConnectors:\n    - type: https\n      port: 8091\n      keyStorePath: &lt;path&gt;\n      keyStorePassword: &lt;password&gt;\n      useForwardedHeaders: true\n</code></pre></p> <p>New config: <pre><code>serverConfig:\n    http-server.http.enabled: false\n    http-server.https.enabled: true\n    http-server.https.port: 8080\n    http-server.https.keystore.path: &lt;path&gt;\n    http-server.https.keystore.key: &lt;password&gt;\n</code></pre></p>"},{"location":"migration-to-airlift/#logging","title":"Logging","text":"<p>Old config:</p> <ul> <li>Set logging to external <pre><code>logging:\n    type: external\n</code></pre></li> <li>Also specify the path to the <code>log.properties</code> file using the <code>log.levels-file</code>   JVM options, such as <code>-Dlog.levels-file=etc/log.properties</code>.</li> </ul> <p>New config:</p> <ul> <li>Specify the path to the <code>log.properties</code> file in config <pre><code>serverConfig:\n    log.levels-file: gateway-ha/etc/log.properties\n</code></pre></li> <li>The <code>log.levels-file</code> JVM option is no longer supported.</li> </ul>"},{"location":"migration-to-airlift/#jvm-startup-arguments","title":"JVM startup arguments","text":"<p>The first arg <code>server</code> has been removed.</p> <p>Old config: <pre><code>java -jar gateway-ha.jar server gateway-config.yml\n</code></pre></p> <p>New config: <pre><code>java -jar gateway-ha.jar gateway-config.yml\n</code></pre></p>"},{"location":"migration-to-airlift/#format-of-extrawhitelistpaths","title":"Format of <code>extraWhitelistPaths</code>","text":"<p>The path setting in <code>extraWhitelistPaths</code> is now a regex that matches the full URI in the request. The old version forwards requests with a URI prefix that matches any path in <code>extraWhitelistPaths</code>. The new version takes regexes from <code>extraWhitelistPaths</code> and forwards only those requests with a URI that exactly matches any of the regexes. This change is required because in the old version, <code>/</code> matches and forwards every request.</p> <p>Be sure to use single-quoted strings so that escaping is not required. The following configurations are equivalent.</p> <p>Old config: <pre><code>extraWhitelistPaths:\n    - \"/ui\"\n    - \"/v1/custom\"\n</code></pre></p> <p>New config: <pre><code>extraWhitelistPaths:\n    - '/ui.*'\n    - '/v1/custom.*'\n</code></pre></p>"},{"location":"migration-to-airlift/#jvm-options","title":"JVM options","text":"<p>The following JVM options are no longer required:</p> <pre><code>-Dlog.levels-file=XXX\n--add-opens=java.base/java.lang=ALL-UNNAMED\n--add-opens=java.base/java.net=ALL-UNNAMED\n</code></pre>"},{"location":"migration-to-airlift/#miscellaneous-changes","title":"Miscellaneous changes","text":"<p>The following section details a number of other changes.</p>"},{"location":"migration-to-airlift/#use-port-8080-and-8443","title":"Use port 8080 and 8443","text":"<p>Use port 8080 for HTTP and 8443 for HTTPS in all the documentations, Docker image and example config file. The use of the ports 9080, 9081, 9082 has been removed. This enhances the consistency throughout the project.</p>"},{"location":"migration-to-airlift/#request-logging","title":"Request logging","text":"<p><code>dropwizard-request-logging</code> has been removed. Airlift provides logging for the  HTTP requests. See Logging properties  for configuration.</p>"},{"location":"operation/","title":"Operation","text":"<p>The following aspects apply to managing Trino Gateway and the connected Trino clusters.</p>"},{"location":"operation/#query-history-ui-check-query-plans-etc","title":"Query History UI - check query plans etc.","text":"<p>Trino Gateway records history of recent queries and displays links to check query details page in respective trino cluster. </p>"},{"location":"operation/#admin-ui-add-and-modify-backend-information","title":"Admin UI - add and modify backend information","text":"<p>The admin page is used to configure the gateway to multiple backends. Existing backend information can also be modified using the same.</p> <p></p>"},{"location":"operation/#graceful-shutdown","title":"Graceful shutdown","text":"<p>Trino Gateway supports graceful shutdown of Trino clusters. Even when a cluster is deactivated, any submitted query states can still be retrieved based on the Query ID.</p> <p>To graceful shutdown a trino cluster without query losses, the steps are:</p> <ol> <li>Set the backend to deactivate state, this prevents any new incoming queries    from getting assigned to the backend.</li> <li>Poll the trino backend coorinator URL until the queued query count and the    running query count both hit 0.</li> <li>Terminate the trino Coordinator &amp; Worker Java process.</li> </ol> <p>To gracefully shutdown a single worker process, refer to the Trino  documentation for more details.</p>"},{"location":"operation/#query-routing-options","title":"Query routing options","text":"<ul> <li>The default router selects the backend randomly to route the queries. </li> <li>If you want to route the queries to the least loaded backend for a user i.e. backend with the least number of queries running or queued from a particular user, then use <code>QueryCountBasedRouter</code>, it can be configured by adding the module name  to config file's modules section like below</li> </ul> <p><pre><code>modules:\n  - io.trino.gateway.ha.module.HaGatewayProviderModule\n  - io.trino.gateway.ha.module.ClusterStateListenerModule\n  - io.trino.gateway.ha.module.ClusterStatsMonitorModule\n  - io.trino.gateway.ha.module.QueryCountBasedRouterProvider\n</code></pre> - The router works on the stats it receives from the clusters about the load i.e number queries queued and running on a cluster at regular intervals which can be configured like below. The default interval is 1 min <pre><code>monitor:\n  taskDelaySeconds: 10\n</code></pre></p>"},{"location":"operation/#monitoring","title":"Monitoring","text":"<p>Trino Gateway provides a metrics endpoint that uses the OpenMetrics format at  <code>/metrics</code>. Use it to monitor Trino Gateway instances with Prometheus and  other compatible systems with the following Prometheus configuration:</p> <pre><code>scrape_configs:\n- job_name: trino_gateway\n  static_configs:\n    - targets:\n        - gateway1.example.com:8080\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>The scripts from this quickstart guide set up a local environment consisting of two Trino servers and a PostgreSQL database running in Docker, and a Trino Gateway server running in the host operating system. </p>"},{"location":"quickstart/#start-trino-gateway-server","title":"Start Trino Gateway server","text":"<p>The following script starts a Trino Gateway server using the  Quickstart configuration at http://localhost:8080. It also starts a dockerized PostgreSQL database at localhost:5432.</p> <p>To start the server, copy the script below to a temporary directory  under the project root folder, and run it at the temporary directory.</p> <p>It  copies the following, necessary files to current directory:</p> <ul> <li>gateway-ha.jar</li> <li>gateway-ha-persistence-postgres.sql</li> <li>quickstart-config.yaml</li> </ul> <pre><code>#!/usr/bin/env sh\n\nVERSION=11\n\n# Copy necessary files to current directory\n\n# Check and get the Gateway Jar\nif [[ -f \"gateway-ha.jar\" ]]; then\n    echo \"Found gateway-har.jar file in current directory.\"\nelse\n    echo \"Failed to find gateway-ha.jar in current directory. Fetching version $VERSION from Maven Central repository.\"\n    curl https://repo1.maven.org/maven2/io/trino/gateway/gateway-ha/${VERSION}/gateway-ha-${VERSION}-jar-with-dependencies.jar -o ./gateway-ha.jar\nfi\n\n# Check and get the Config.yaml\nif [[ -f \"quickstart-config.yaml\" ]]; then\n    echo \"Found quickstart-config.yaml file in current directory.\"\nelse\n    cp ../docs/quickstart-config.yaml ./quickstart-config.yaml\nfi\n\n# Check and get the postgres.sql\nif [[ -f \"gateway-ha-persistence-postgres.sql\" ]]; then\n    echo \"Found gateway-ha-persistence-postgres.sql file in current directory.\"\nelse\n    cp ../gateway-ha/src/main/resources/gateway-ha-persistence-postgres.sql ./gateway-ha-persistence-postgres.sql\nfi\n\n#Check if DB is running\nif docker ps --format '{{.Names}}' | grep -q '^local-postgres$'; then\n    echo \"PostgreSQL database container 'localhost-postgres' is already running. Only starting Trino Gateway.\"\nelse\n    echo \"PostgreSQL database container 'localhost-postgres' is not running. Proceeding to initialize and run database server.\"\n    export PGPASSWORD=mysecretpassword\n    docker run -v \"$(pwd)\"/gateway-ha-persistence-postgres.sql:/tmp/gateway-ha-persistence-postgres.sql --name local-postgres -p 5432:5432 -e POSTGRES_PASSWORD=$PGPASSWORD -d postgres:latest\n    #Make sure the DB has time to initialize\n    sleep 5\n\n    #Initialize the DB\n    docker exec local-postgres psql -U postgres -h localhost -c 'CREATE DATABASE gateway'\n    docker exec local-postgres psql -U postgres -h localhost -d gateway -f /tmp/gateway-ha-persistence-postgres.sql\nfi\n\n\n#Start Trino Gateway server.\njava -Xmx1g -jar ./gateway-ha.jar ./quickstart-config.yaml\n</code></pre> <p>You can clean up by running</p> <pre><code>docker kill local-postgres &amp;&amp; docker rm local-postgres\nkill -5 $(jps | grep gateway-ha.jar | cut -d' ' -f1)\n</code></pre>"},{"location":"quickstart/#add-trino-backends","title":"Add Trino backends","text":"<p>This following script starts two dockerized Trino servers at  http://localhost:8081 and http://localhost:8082. It then adds them as backends to the Trino Gateway server started by the preceding script.</p> <pre><code>#!/usr/bin/env sh\n\n#Start a pair of trino servers on different ports\ndocker run --name trino1 -d -p 8081:8080 -e JAVA_TOOL_OPTIONS=\"-Dhttp-server.process-forwarded=true\" trinodb/trino\ndocker run --name trino2 -d -p 8082:8080 -e JAVA_TOOL_OPTIONS=\"-Dhttp-server.process-forwarded=true\" trinodb/trino\n\n#Add the trino servers as Gateway backends\ncurl -H \"Content-Type: application/json\" -X POST localhost:8080/gateway/backend/modify/add -d '{\"name\": \"trino1\",\n                                                                                                \"proxyTo\": \"http://localhost:8081\",\n                                                                                                \"active\": true,\n                                                                                                \"routingGroup\": \"adhoc\"\n                                                                                              }'\ncurl -H \"Content-Type: application/json\" -X POST localhost:8080/gateway/backend/modify/add -d '{\"name\": \"trino2\",\n                                                                                                \"proxyTo\": \"http://localhost:8082\",\n                                                                                                \"active\": true,\n                                                                                                \"routingGroup\": \"adhoc\"\n                                                                                              }'\n</code></pre> <p>You can clean up by running</p> <pre><code>docker kill trino1 &amp;&amp; docker rm trino1\ndocker kill trino2 &amp;&amp; docker rm trino2\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#trino-gateway-11-12-sep-2024","title":"Trino Gateway 11 (12 Sep 2024)","text":"<p>JAR file gateway-ha-11-jar-with-dependencies.jar, Container image <code>trinodb/trino-gateway:11</code></p> <ul> <li> Breaking change: Require Java 22 for build and runtime.   (#441)</li> <li>Add support for determining routing group in an external service.   (#423)</li> <li>Add an option to forward requests without adding <code>X-Forwarded-*</code> HTTP headers   with the <code>addXForwardedHeaders: false</code> configuration in <code>routing</code>.   (#417)</li> <li>Add OpenMetrics endpoint to   enable monitoring with Prometheus and compatible systems.   (#429)</li> <li>Add option to deactivate hostname verification for the certificate    of the Trino clusters.   (#436)</li> <li>Add option to use additional paths as Trino client REST API endpoints.   (#326)</li> <li>Add timeout parameters for INFO_API and JDBC health checks.   (#424)</li> <li>Add support for specifying custom labels in the Helm chart <code>commonLabels</code>.   (#448)</li> <li>Enable routing for requests to kill query processing.   (#427)</li> <li>Fix routing functionality and query history issues caused by lowercase    HTTP headers in HTTP/2 connections.   (#450)</li> <li>Fix failures when clients use HTTP/2.   (#451)</li> <li>Ensure that the user history dashboard displays the correct user name.   (#370)</li> <li>Fix incorrect routing of OAuth logout requests.   (#455)</li> </ul> <p>More details and a list of all merged pull requests are available in the  milestone 11 list.</p>"},{"location":"release-notes/#trino-gateway-10-24-jul-2024","title":"Trino Gateway 10 (24 Jul 2024)","text":"<p>JAR file gateway-ha-10-jar-with-dependencies.jar, Container image <code>trinodb/trino-gateway:10</code></p> <ul> <li> Breaking change: Remove support for Dropwizard and   Jetty Proxy integration and usage. Add   Airlift as the base application   framework as   used in Trino. This changes the supported Trino Gateway startup, configuration   files, and relevant properties. Find details in the   documentation, and specifically refer to the   upgrade guide when migrating from older releases.   (#41)</li> <li> Breaking change: Improve Helm chart reliability and   adjust to new Airlift base framework.   (#401)</li> <li>Enable routing rules to use query and user details extracted from the HTTP   request.   (#325)</li> <li>Add support for using an OIDC claim for authorization.   (#322)</li> <li>Improve OIDC spec compliance, and add state and nonce verification.   (#348)</li> <li>Allow null values for <code>userName</code> and <code>source</code> in the query history.   (#381)</li> <li>Show times in query distribution graph in UI in local time instead of UTC.   (#369)</li> <li>Fix problems with secrets, liveness, and readiness templates in Helm chart.   (#348)</li> <li>Fix cluster reordering issue in the cluster user interface.   (#331)</li> <li>Fix creation of new resource groups.   (#379)</li> </ul>"},{"location":"release-notes/#trino-gateway-9-8-may-2024","title":"Trino Gateway 9 (8 May 2024)","text":"<p>JAR file gateway-ha-9-jar-with-dependencies.jar, Container image <code>trinodb/trino-gateway:9</code></p> <ul> <li>Ensure inclusion of UI in JAR and container artifacts. (#337)</li> </ul>"},{"location":"release-notes/#trino-gateway-8-6-may-2024","title":"Trino Gateway 8 (6 May 2024)","text":"<p>JAR file gateway-ha-8-jar-with-dependencies.jar, Container image <code>trinodb/trino-gateway:8</code></p> <ul> <li>Add support for configurable router policies. (#98)</li> <li>Add a router policy based on query count per cluster. (#98)</li> <li>Add a router policy for select paths based on cookie content. (#188)</li> <li>Support configuring access permissions for UI pages. (#296)</li> <li>Add Helm chart for Kubernetes deployments. (#87)</li> <li>Require Java 21 for build and runtime. (#225)</li> <li>Fix the <code>userInfo</code> resource to pass role information used by the API, so that   the webapp authentication matches the API authentication. (#310)</li> </ul>"},{"location":"release-notes/#trino-gateway-7-21-mar-2024","title":"Trino Gateway 7 (21 Mar 2024)","text":"<p>JAR file gateway-ha-7-jar-with-dependencies.jar, Container image <code>trinodb/trino-gateway:7</code></p> <ul> <li>Replace user interface with a new modern UI. (#116)</li> <li>Improve logging configurability. Users must update to the    new logging configuration. (#260)</li> <li>Improve Trino cluster health check performance and remove authentication requirement    by using the <code>v1/info</code> endpoint. (#264)</li> <li>Fix query id tracking based on request querystring parsing. (#265)</li> </ul> <p>Details about all pull requests and issues</p>"},{"location":"release-notes/#trino-gateway-6-16-feb-2024","title":"Trino Gateway 6 (16 Feb 2024)","text":"<p>JAR file gateway-ha-6-jar-with-dependencies.jar, Container image <code>trinodb/trino-gateway:6</code></p> <ul> <li>Add Docker container build, publishing, and usage setup and instructions. (#86)</li> </ul> <p>Details about all pull requests and issues</p>"},{"location":"release-notes/#trino-gateway-5-24-jan-2024","title":"Trino Gateway 5 (24 Jan 2024)","text":"<p>gateway-ha-5-jar-with-dependencies.jar</p> <ul> <li>Add support for OAuth 2 audience use. (#164)</li> <li>Add quickstart scripts and documentation. (#110)</li> <li>Add project logo. (#111)</li> <li>Prevent ignoring HTTP header configuration. (#100)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#trino-gateway-4-30-nov-2023","title":"Trino Gateway 4 (30 Nov 2023)","text":"<p>gateway-ha-4-jar-with-dependencies.jar</p> <ul> <li>Add support for configuring additional whitelisted URL paths. (#63)</li> <li>Improve flexibility of user and group name matching for authorization. (#32)</li> <li>Add support to use external URL for backend creation. (#76)</li> <li>Enable configuration of HTTP header size. (#67)</li> <li>Automatically set JDBC configuration parameter for TLS when connecting to   clusters for monitoring. (#71)</li> <li>Modernize application and remove potential for undiscovered bugs and security   issues with update of many core dependencies. (#59)</li> <li>Avoid failure when unhandled OIDC properties are present. (#69)</li> <li>Prevent failures resulting from reloading and parsing rules file. (#5)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#trino-gateway-3-26-sep-2023","title":"Trino Gateway 3 (26 Sep 2023)","text":"<p>gateway-ha-3-jar-with-dependencies.jar</p> <p>The first release of Trino Gateway is based on the  Presto Gateway 1.9.5 codebase (#4) with these additions:</p> <ul> <li>Add authentication and authorization with LDAP, OIDC and user list from config   file. (#9)</li> <li>Add support for user, admin and API roles. (#9)</li> <li>Add healthcheck for Trino backends using JDBC. (#9)</li> <li>Add TCP check for routing. (#9)</li> <li>Add logic to route requests only to healthy backends. (#13)</li> <li>Add PostgreSQL support for backend database. (#13)</li> <li>Allow routing of <code>/v1/node</code> endpoint URL. (#27)</li> <li>Filter logs for sensitive information. (#9)</li> <li>Require Java 17 for build and runtime. (#16)</li> <li>Deactivate clusters with zero workers. (#13)</li> <li>Remove concurrency issue from repeated rules file loading. (#9)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#breaking-changes","title":"Breaking changes  <p>Starting with Trino Gateway 10, release note entries include a  Breaking change: prefix to highlight any changes as potentially  breaking changes. The following changes are considered and may require adjustments:</p> <ul> <li>Removal or renaming of configuration properties that may prevent startup or    require configuration changes.</li> <li>Changes to default values for configuration properties that may significantly   change the behavior of a system.</li> <li>Updates to the requirements for external systems or software used with    Trino Gateway.</li> <li>Non-backwards compatible changes which may require router modules to    be updated.</li> <li>Otherwise significant changes that requires specific attention from teams    managing a Trino Gateway deployment.</li> </ul>","text":""},{"location":"resource-groups-api/","title":"Resource groups API","text":"<p>Trino Gateway facilitates the management of resource groups across multiple Trino clusters, using the database resource group manager. It allows users to connect their Trino clusters to a centralized resource groups table maintained in the Trino Gateway's database. This setup enables management of resource groups either through the API or the Trino Gateway user interface.</p> <p>Trino offers both file-based and database resource group management. Using Trino Gateway with database management avoids the need for cluster re-deployments when updating resource groups, enhancing operational efficiency.</p> <p>For resource group and selector apis, we can now specify a query parameter with the request supporting multiple trino databases for different trino backends. This allows a user to configure a db for every trino backend with their own resource groups and selector tables. To use this, just specify the query parameter ?useSchema= to the request. Example, to list all resource groups, <pre><code>curl -X GET http://localhost:8080/trino/resourcegroup/read/{INSERT_ID_HERE}?useSchema=newdatabasename\n</code></pre>"},{"location":"resource-groups-api/#add-a-resource-group","title":"Add a resource group","text":"<p>To add a single resource group, specify all relevant fields in the body. Resource group id should not be specified since the database should autoincrement it.</p> <pre><code>curl -X POST http://localhost:8080/trino/resourcegroup/create \\\n -d '{\n        \"name\": \"resourcegroup1\", \\\n        \"softMemoryLimit\": \"100%\", \\\n        \"maxQueued\": 100, \\\n        \"softConcurrencyLimit\": 100, \\\n        \"hardConcurrencyLimit\": 100, \\\n        \"schedulingPolicy\": null, \\\n        \"schedulingWeight\": null, \\\n        \"jmxExport\": null, \\\n        \"softCpuLimit\": null, \\\n        \"hardCpuLimit\": null, \\\n        \"parent\": null, \\\n        \"environment\": \"test\" \\\n    }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-resource-groups","title":"Get existing resource group(s)","text":"<p>If no resourceGroupId (type long) is specified, then all existing resource groups are fetched.</p> <pre><code>curl -X GET http://localhost:8080/trino/resourcegroup/read/{INSERT_ID_HERE}\n</code></pre>"},{"location":"resource-groups-api/#update-a-resource-group","title":"Update a resource group","text":"<p>Specify all columns in the body, which will overwrite properties for the resource group with that specific resourceGroupId.</p> <pre><code>curl -X POST http://localhost:8080/trino/resourcegroup/update \\\n -d '{  \"resourceGroupId\": 1, \\\n        \"name\": \"resourcegroup_updated\", \\\n        \"softMemoryLimit\": \"80%\", \\\n        \"maxQueued\": 50, \\\n        \"softConcurrencyLimit\": 40, \\\n        \"hardConcurrencyLimit\": 60, \\\n        \"schedulingPolicy\": null, \\\n        \"schedulingWeight\": null, \\\n        \"jmxExport\": null, \\\n        \"softCpuLimit\": null, \\\n        \"hardCpuLimit\": null, \\\n        \"parent\": null, \\\n        \"environment\": \"test\" \\\n    }'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-resource-group","title":"Delete a resource group","text":"<p>To delete a resource group, specify the corresponding resourceGroupId (type long).</p> <pre><code>curl -X POST http://localhost:8080/trino/resourcegroup/delete/{INSERT_ID_HERE}\n</code></pre>"},{"location":"resource-groups-api/#add-a-selector","title":"Add a selector","text":"<p>To add a single selector, specify all relevant fields in the body. Resource group id should not be specified since the database should autoincrement it.</p> <pre><code>curl -X POST http://localhost:8080/trino/selector/create \\\n -d '{\n        \"priority\": 1, \\\n        \"userRegex\": \"selector1\", \\\n        \"sourceRegex\": \"resourcegroup1\", \\\n        \"queryType\": \"insert\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-selectorss","title":"Get existing selectors(s)","text":"<p>If no resourceGroupId (type long) is specified, then all existing selectors are fetched.</p> <pre><code>curl -X GET http://localhost:8080/trino/selector/read/{INSERT_ID_HERE}\n</code></pre>"},{"location":"resource-groups-api/#update-a-selector","title":"Update a selector","text":"<p>To update a selector, the existing selector must be specified with all relevant fields under \"current\". The updated version of that selector is specified under \"update\", with all relevant fields included. If the selector under \"current\" does not exist, a new selector will be created with the details under \"update\". Both \"current\" and \"update\" must be included to update a selector.</p> <pre><code>curl -X POST http://localhost:8080/trino/selector/update \\\n -d '{  \"current\": {\n            \"resourceGroupId\": 1, \\\n            \"priority\": 1, \\\n            \"userRegex\": \"selector1\", \\\n            \"sourceRegex\": \"resourcegroup1\", \\\n            \"queryType\": \"insert\" \\\n        },\n        \"update\":  {\n            \"resourceGroupId\": 1, \\\n            \"priority\": 2, \\\n            \"userRegex\": \"selector1_updated\", \\\n            \"sourceRegex\": \"resourcegroup1\", \\\n            \"queryType\": null \\\n        }\n}'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-selector","title":"Delete a selector","text":"<p>To delete a selector, specify all relevant fields in the body.</p> <pre><code>curl -X POST http://localhost:8080/trino/selector/delete \\\n -d '{  \"resourceGroupId\": 1, \\\n        \"priority\": 2, \\\n        \"userRegex\": \"selector1_updated\", \\\n        \"sourceRegex\": \"resourcegroup1\", \\\n        \"queryType\": null \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#add-a-global-property","title":"Add a global property","text":"<p>To add a single global property, specify all relevant fields in the body.</p> <pre><code>curl -X POST http://localhost:8080/trino/globalproperty/create \\\n -d '{\n        \"name\": \"cpu_quota_period\", \\\n        \"value\": \"1h\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-global-properties","title":"Get existing global properties","text":"<p>If no name (type String) is specified, then all existing global properties are fetched.</p> <pre><code>curl -X GET http://localhost:8080/trino/globalproperty/read/{INSERT_NAME_HERE}\n</code></pre>"},{"location":"resource-groups-api/#update-a-global-property","title":"Update a global property","text":"<p>Specify all columns in the body, which will overwrite properties for the global property with that specific name.</p> <pre><code>curl -X POST http://localhost:8080/trino/globalproperty/update \\\n -d '{\n        \"name\": \"cpu_quota_period\", \\\n        \"value\": \"2h\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-global-property","title":"Delete a global property","text":"<p>To delete a global property, specify the corresponding name (type String).</p> <pre><code>curl -X POST http://localhost:8080/trino/globalproperty/delete/{INSERT_NAME_HERE}\n</code></pre>"},{"location":"routers/","title":"Routers","text":"<p>Trino Gateway offers two entry-level router options, providing users with a  straightforward and easy-to-use starting point for their routing needs. The  routers make the decision based on the clusters load reported in ClusterStats.</p>"},{"location":"routers/#stochasticroutingmanager","title":"StochasticRoutingManager","text":"<p>This primary routing mechanism employs a straightforward, decentralized  approach, dispatching incoming queries in a random manner without utilizing  advanced optimization techniques.</p>"},{"location":"routers/#querycountbasedrouterprovider","title":"QueryCountBasedRouterProvider","text":"<p>This routing mechanism utilizes near real-time, user-level cluster load statistics. It uses running queries count and query queue lengths to determine the most suitable cluster for each individual user. With is information it  directs queries to the least loaded cluster for that user, optimizing the  likelihood of successful execution.</p>"},{"location":"routers/#adding-a-routing-mechanism","title":"Adding a routing mechanism","text":"<p>To enhance Trino Gateway's capabilities, you can create and contribute new and advanced router modules with intelligent routing features. To integrate a new router, you need to create a provider module that can be configured via the  configuration file. This allows for seamless addition of new routers without disrupting existing functionality.</p>"},{"location":"routers/#add-router-provider-module","title":"Add router Provider module","text":"<p>Use the following steps to incorporate a new routing mechanism with advanced capabilities:</p> <ul> <li>Derive a class from <code>RouterBaseModule</code></li> <li>The module must instantiate the router and hold a reference to it.</li> <li>Add the module name to the <code>modules</code> section of the configuration file to load    the provider module and make the new router available.</li> <li>For example, <code>QueryCountBasedRouterProvider</code> and refer to the config file in    the following sections.</li> </ul>"},{"location":"routers/#add-router-class","title":"Add router class","text":"<p>Use the following steps to create a new router:</p> <ul> <li>Derive a class from <code>StochasticRoutingManager</code> to create the router that    does the actual work.</li> <li>Override the methods <code>provideAdhocBackend</code> and <code>provideBackendForRoutingGroup</code>   and implement the new smarter logic</li> <li>The router listens to the list of <code>ClusterStats</code> via the<code>updateBackEndStats</code>   method.</li> <li>This method is called on regular intervals defined in the config    parameter <code>monitor=&gt;taskDelaySeconds</code>.</li> <li>Each element in the list corresponds to each backend cluster.</li> <li>Only the stats from the healthy cluster are reported, unhealthy clusters are   not included in the list. If you have three cluster backends and one is   unhealthy, then the parameter <code>List&lt;ClusterStats&gt; stats</code> has only two   elements.</li> <li>To get the cluster stats set the parameter   <code>clusterStatsConfiguration=&gt;monitorType</code> to <code>UI_API</code> or <code>JDBC</code> which in turn   needs the setup of <code>backendState</code> section in the config file.</li> </ul>"},{"location":"routers/#configuration-file-reference","title":"Configuration file reference","text":"<pre><code>backendState:\n  username: &lt;usernme&gt;\n  password: &lt;password&gt;\n  ssl: &lt;false/true&gt;\n\nclusterStatsConfiguration:\n  monitorType: UI_API\n\nmonitor:\n  taskDelaySeconds: 10\n\nmodules:\n  - io.trino.gateway.ha.module.QueryCountBasedRouterProvider\n</code></pre>"},{"location":"routing-logic/","title":"Routing Logic","text":""},{"location":"routing-logic/#overview","title":"Overview","text":"<p>Trino Gateway checks incoming requests to see if they're related to previous  ones it handled. If they are, then Trino Gateway sends them to the same backend  that dealt with the earlier requests.</p> <p>If it is a new request, the Trino Gateway refers to Routing rules  to decide which group of backends, called a 'Routing Group,' should handle it.  It then picks a backend from that Routing Group to handle the request using  either an adaptive or round-robin strategy.</p> <p></p>"},{"location":"routing-logic/#sticky-routing","title":"Sticky routing","text":"<p>A request related to an ongoing process, or to state maintained on a single  backend cluster, must be routed to that backend for proper handling. Two  mechanisms for identifying related requests are currently implemented. By default, only routing based on query identifier is enabled.</p>"},{"location":"routing-logic/#routing-based-on-query-identifier-default","title":"Routing based on query identifier (default)","text":"<p>When a query is initiated through the Trino Gateway, the query id will be  extracted from the response and mapped to the backend that provided the  response. Any subsequent request containing that query id will be forwarded  to that backend. For example, to retrieve query results, the trino client  polls a URI of the form  <code>v1/statement/executing/queryid/nonce/counter</code>. The Trino Gateway will extract the queryid from this URI.</p>"},{"location":"routing-logic/#routing-based-on-cookies","title":"Routing based on cookies","text":"<p>OAuth2 authentication requires that the same backend is used for each step of  the handshake. When <code>gatewayCookieConfiguration.enabled</code> is set to true, a cookie  will be added to requests made to paths beginning with <code>/oauth2</code> unless they already have  a cookie present, which is used to route further <code>/oauth2/*</code> requests to the correct backend.  Cookies are not added to requests to <code>v1/*</code> and other Trino endpoints.</p> <p>Trino Gateway signs its cookies to ensure that they are not tampered with. You  must set a <code>cookieSigningSecret</code> string in your configuration <pre><code>gatewayCookieConfiguration:\n    enabled: true\n    cookieSigningSecret: \"ahighentropystring\"\n</code></pre> when making use of this feature. If you load balance request across multiple Trino Gateway instances, ensure each instance has the same <code>cookieSigningSecret</code>.</p> <p>The Trino Gateway handles standard Trino OAuth2 handshakes with no additional  configuration. If you are using a customized or commercial Trino distribution, then the paths used to define the OAuth handshake may be modified.</p> <p><code>routingPaths</code>: If the request URI starts with a path in this list, then * If no cookie is present, add a routing cookie * If a cookie is present, route the request to the backend defined by that cookie</p> <p><code>deletePaths</code>: If the request URI starts with a path in this list, return a response that instructs the client to delete the cookie.</p> <p>Additionally, the <code>lifetime</code> property sets the duration for which a cookie remains in  effect after creation. Ensure that it is greater than the time required to complete the handshake. Default <code>lifetime</code> is 10 minutes.</p> <p>These properties are defined under the <code>oauth2GatewayCookieConfiguration</code> node: </p> <pre><code>oauth2GatewayCookieConfiguration:\n  routingPaths:\n    - \"/oauth2\"\n    - \"/custom/oauth2/callback\"\n    - \"/alternative/oauth2/initiate\"\n  deletePaths:\n    - \"/custom/logout\"\n  lifetime: \"5m\"\n</code></pre>"},{"location":"routing-rules/","title":"Routing rules","text":"<p>Trino Gateway includes a routing rules engine.</p> <p>By default, Trino Gateway reads the <code>X-Trino-Routing-Group</code> request header to route requests. If this header is not specified, requests are sent to default routing group (adhoc).</p> <p>The routing rules engine feature enables you to either write custom logic to route requests based on the request info such as any of the request headers, or set a URL address to make an HTTP POST request and route based on the returned result.</p> <p>Routing rules are separated from Trino Gateway application code to a configuration file or a separate service. This separate service is specified as a URL and can implement any dynamic rule changes or other behavior.</p>"},{"location":"routing-rules/#enabling-the-routing-rules-engine","title":"Enabling the routing rules engine","text":"<p>To enable the routing rules engine, find the following lines in <code>gateway-ha-config.yml</code>.</p> <ul> <li>Set <code>rulesEngineEnabled</code> to <code>true</code>, then <code>rulesType</code> as <code>FILE</code> or <code>EXTERNAL</code>.</li> <li>Then either add <code>rulesConfigPath</code> to the path to your rules config file or set <code>rulesExternalConfiguration</code>   to the URL of an external service for routing rules processing.</li> <li><code>rulesType</code> is by default <code>FILE</code> unless specified.</li> </ul> <pre><code>routingRules:\n    rulesEngineEnabled: true\n    rulesType: FILE\n    rulesConfigPath: \"app/config/routing_rules.yml\" # replace with actual path to your rules config file\n    rulesExternalConfiguration:\n        urlPath: https://router.example.com/gateway-rules # replace with your own API path\n        excludeHeaders:\n            - 'Authorization'\n            - 'Accept-Encoding'\n</code></pre> <ul> <li>Redirect URLs are not supported</li> <li>Optionally add headers to the <code>excludeHeaders</code> list to exclude requests with corresponding header values   from being sent in the POST request.</li> <li>Check headers to exclude when making API requests, specifics depend on the network configuration.</li> </ul> <p>If there is error parsing the routing rules configuration file, an error is logged, and requests are routed using the routing group header <code>X-Trino-Routing-Group</code> as default.</p>"},{"location":"routing-rules/#use-an-external-service-for-routing-rules","title":"Use an external service for routing rules","text":"<p>You can use an external service for processing your routing by setting the <code>rulesType</code> to <code>EXTERNAL</code> and configuring the <code>rulesExternalConfiguration</code>.</p> <p>Trino Gateway then sends all headers as a map in the body of a POST request to the external service. Headers specified in <code>excludeHeaders</code> are excluded. If <code>requestAnalyzerConfig.analyzeRequest</code> is set to <code>true</code>,  <code>TrinoRequestUser</code> and <code>TrinoQueryProperties</code> are also included. </p> <p>Additionally, the following HTTP information is included:</p> <ul> <li><code>remoteUser</code></li> <li><code>method</code></li> <li><code>requestURI</code></li> <li><code>queryString</code></li> <li><code>session</code></li> <li><code>remoteAddr</code></li> <li><code>remoteHost</code></li> <li><code>parameterMap</code></li> </ul> <p>The external service can process the information in any way desired  and must return a result with the following criteria:</p> <ul> <li>Response status code of OK (200)</li> <li>Message in JSON format</li> <li>Only one group can be returned</li> <li>If errors is not null, then query would route to default routing group adhoc </li> </ul> <pre><code>{\n    \"routingGroup\": \"test-group\",\n    \"errors\": [\n        \"Error1\",\n        \"Error2\",\n        \"Error3\"\n    ]\n}\n</code></pre>"},{"location":"routing-rules/#configure-routing-rules-with-a-file","title":"Configure routing rules with a file","text":"<p>To express and fire routing rules, we use the easy-rules engine. These rules should be stored in a YAML file. Rules consist of a name, description, condition, and list of actions. If the condition of a particular rule evaluates to true, its actions are fired.</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl-special\")'\n</code></pre> <p>In the condition, you can access the methods of a HttpServletRequest object called <code>request</code>. Rules may also utilize trinoRequestUser and trinoQueryProperties objects, which provide information about the user and query respectively. There should be at least one action of the form <code>result.put(\\\"routingGroup\\\", \\\"foo\\\")</code> which says that if a request satisfies the condition, it should be routed to <code>foo</code>.</p> <p>The condition and actions are written in MVEL, an expression language with Java-like syntax. In most cases, users can write their conditions/actions in Java syntax and expect it to work. There are some MVEL-specific operators that could be useful though. For example, instead of doing a null-check before accessing the <code>String.contains</code> method like this:</p> <pre><code>condition: 'request.getHeader(\"X-Trino-Client-Tags\") != null &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\").contains(\"label=foo\")'\n</code></pre> <p>You can use the <code>contains</code> operator</p> <pre><code>condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=foo\"'\n</code></pre> <p>If no rules match, then request is routed to adhoc.</p>"},{"location":"routing-rules/#trinostatus","title":"TrinoStatus","text":"<p>This class attempts to track the current state of Trino cluster. It is updated per every healthcheck. There are three possible states</p> <ul> <li>PENDING<ul> <li>A Trino cluster will show this state when it is still starting up. It will be treated as   unhealthy by RoutingManager, and therefore requests will not be routed to PENDING clusters</li> </ul> </li> <li>HEALTHY<ul> <li>A Trino cluster will show this state when healthchecks report clusters as healthy and ready.   RoutingManager will only route requests to healthy clusters</li> </ul> </li> <li>UNHEALTHY<ul> <li>A Trino cluster will show this state when healthchecks report clusters as unhealthy. RoutingManager   will not route requests to unhealthy clusters.</li> </ul> </li> </ul>"},{"location":"routing-rules/#trinorequestuser","title":"TrinoRequestUser","text":"<p>This class attempts to extract the user from a request. In order, it attempts</p> <ol> <li>The <code>X-Trino-User</code> header</li> <li>The <code>Authorization: Basic</code> header</li> <li>The <code>Authorization: Bearer</code> header. Requires configuring an OAuth2 User Info URL</li> <li>The <code>Trino-UI-Token</code> or <code>__Secure-Trino-ID-Token</code> cookie</li> </ol> <p>Kerberos and Certificate authentication are not currently supported. If the  request contains the <code>Authorization: Bearer</code> header, an attempt will be made to treat the token as a JWT and deserialize it. If this is successful, the  value of the claim named in <code>requestAnalyzerConfig.tokenUserField</code> is used as the username. By default, this is the <code>email</code> claim. If the token is not a valid JWT, and <code>requestAnalyzerConfig.oauthTokenInfoUrl</code> is configured, then the token will be exchanged with the Info URL. Responses are cached for 10 minutes to avoid triggering rate limits. </p> <p>You may call <code>trinoRequestUser.getUser()</code> and <code>trinoRequestUser.getUserInfo()</code> in your routing rules. If a user was not successfully extracted, <code>trinoRequestUser.getUser()</code> will return an empty Optional. <code>trinoRequestUser.getUserInfo()</code> will return an Optional\\&lt;UserInfo&gt; if a token is successfully exchanged with the <code>oauthTokenInfoUrl</code>, and an empty <code>Optional</code> otherwise.</p> <p><code>trinoRequestUser.userExistsAndEquals(\"usernameToTest\")</code> can be used to check a username against the extracted user. It will return <code>False</code> if a user has not been extracted.</p> <p>User extraction is only available if enabled by configuring <code>requestAnalyzerConfig.analyzeRequest = True</code></p>"},{"location":"routing-rules/#trinoqueryproperties","title":"TrinoQueryProperties","text":"<p>This class attempts to parse the body of a request as SQL. Note that only a syntactic analysis is performed! If a query \u0153references a view, then that view will not be expanded, and tables referenced by the view will not be recognized. Note that Views and Materialized Views are treated as tables and added to the list of tables in all contexts, including  statements such as <code>CREATE VIEW</code>.</p> <p>A routing rule can call the following methods on the <code>trinoQueryProperties</code> object:</p> <ul> <li><code>boolean isNewQuerySubmission()</code>: is the request a POST to the <code>v1/statement</code>   query endpoint.</li> <li><code>boolean isQueryParsingSuccessful()</code>: was the request successfully parsed. </li> <li><code>String getQueryType()</code>: the class name of the <code>Statement</code>, e.g. <code>ShowCreate</code>.   Note that these are not mapped to the <code>ResourceGroup</code> query types. For a full   list of potential query types, see the classes in   STATEMENT_QUERY_TYPES</li> <li><code>String getResourceGroupQueryType()</code>: the Resource Group query type, for   example <code>SELECT</code>, <code>DATA_DEFINITION</code>. For a full list see queryType in   the Trino documentation</li> <li><code>String getDefaultCatalog()</code>: the default catalog, if set. It may or may not   be referenced in the actual SQL</li> <li><code>String getDefaultSchema()</code>: the default schema,  if set. It may or may not   be referenced in the actual SQL</li> <li><code>Set&lt;String&gt; getCatalogs()</code>: the set of catalogs used in the query. Includes   the default catalog if used by a non-fully qualified table reference</li> <li><code>Set&lt;String&gt; getSchemas()</code>: the set of schemas used in the query. Includes the   default schema if used by a non-fully qualified table reference</li> <li><code>Set&lt;String&gt; getCatalogSchemas()</code> the set of qualified schemas used in the   query, in the form <code>catalog.schema</code></li> <li><code>boolean tablesContains(String testName)</code> returns true if the query contains a   reference to the table <code>testName</code>.<code>testName</code> should be fully qualified, for   example <code>testcat.testschema.testtable</code></li> <li><code>Set&lt;QualifiedName&gt; getTables()</code>: the set of tables used in the query. These   are fully qualified, any partially qualified table reference in the SQL   will be qualified by the default catalog and schema.</li> <li><code>String getBody()</code>: the raw request body</li> </ul>"},{"location":"routing-rules/#configuration","title":"Configuration","text":"<p>The <code>trinoQueryProperties</code>  are configured under the <code>requestAnalyzerConfig</code> configuration  node.</p>"},{"location":"routing-rules/#analyzerequest","title":"analyzeRequest","text":"<p>Set to <code>True</code> to make <code>trinoQueryProperties</code> and <code>trinoRequestUser</code> available</p>"},{"location":"routing-rules/#maxbodysize","title":"maxBodySize","text":"<p>By default, the max body size is 1,000,000 characters. This can be modified by configuring <code>maxBodySize</code>. If the request body is greater or equal to this  limit, Trino Gateway will not process the query. A buffer of length  <code>maxBodySize</code> will be allocated per query, so reduce this value if you observe excessive GC. <code>maxBodySize</code> cannot be set to values larger than 2**31-1, the  maximum size of a Java String.</p>"},{"location":"routing-rules/#isclientsusev2format","title":"isClientsUseV2Format","text":"<p>Some commercial extensions to Trino use the V2 Request Structure V2 style request structure. Support for V2-style requests can be enabled by setting this property to true. If you use a commercial version of Trino, ask your vendor how to set this configuration. </p>"},{"location":"routing-rules/#tokenuserfield","title":"tokenUserField","text":"<p>When extracting the user from a JWT token, this field is used as the username. By default, the <code>email</code> claim is used. </p>"},{"location":"routing-rules/#oauthtokeninfourl","title":"oauthTokenInfoUrl","text":"<p>If configured, then Trino will attempt to retrieve user info by exchanging potential authorization tokens with this URL. Responses are cached for 10 minutes to avoid triggering rate limits.</p>"},{"location":"routing-rules/#execution-of-rules","title":"Execution of Rules","text":"<p>All rules whose conditions are satisfied will fire. For example, in the \"airflow\" and \"airflow special\" example rules given above, a query with source <code>airflow</code> and label <code>special</code> will satisfy both rules. The <code>routingGroup</code> is set to <code>etl</code> and then to <code>etl-special</code> because of the order in which the rules of defined. If we swap the order of the rules, then we would possibly get <code>etl</code> instead, which is undesirable.</p> <p>One could solve this by writing the rules such that they're atomic (any query will match exactly one rule). For example we can change the first rule to</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") == null'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\n</code></pre> <p>This could be hard to maintain as we add more rules. To have better control over the execution of rules, we could use rule priorities and composite rules. Overall, with priorities, composite rules, and the constructs that MVEL support, you should likely be able to express your routing logic.</p>"},{"location":"routing-rules/#rule-priority","title":"Rule Priority","text":"<p>We can assign an integer value <code>priority</code> to a rule. The lower this integer is, the earlier it will fire. If the priority is not specified, the priority is defaulted to INT_MAX. We can add priorities to our airflow and airflow special rule like so:</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\npriority: 0\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\npriority: 1\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl-special\")'\n</code></pre> <p>Note that both rules will still fire. The difference is that we've guaranteed that the first rule (priority 0) is fired before the second rule (priority 1). Thus <code>routingGroup</code> is set to <code>etl</code> and then to <code>etl-special</code>, so the <code>routingGroup</code> will always be <code>etl-special</code> in the end.</p> <p>Above, the more specific rules have less priority since we want them to be the last to set <code>routingGroup</code>. This is a little counterintuitive. To further control the execution of rules, for example to have only one rule fire, we can use composite rules.</p>"},{"location":"routing-rules/#composite-rules","title":"Composite Rules","text":"<p>First, please refer to easy-rule composite rules docs: https://github.com/j-easy/easy-rules/wiki/defining-rules#composite-rules</p> <p>Above, we saw how to control the order of rule execution using priorities. In addition to this, we could have only the first rule matched to be fired (the highest priority one) and the rest ignored. We can use <code>ActivationRuleGroup</code> to achieve this.</p> <pre><code>---\nname: \"airflow rule group\"\ndescription: \"routing rules for query from airflow\"\ncompositeRuleType: \"ActivationRuleGroup\"\ncomposingRules:\n  - name: \"airflow special\"\n    description: \"if query from airflow with special label, route to etl-special group\"\n    priority: 0\n    condition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\n    actions:\n      - 'result.put(\"routingGroup\", \"etl-special\")'\n  - name: \"airflow\"\n    description: \"if query from airflow, route to etl group\"\n    priority: 1\n    condition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\n    actions:\n      - 'result.put(\"routingGroup\", \"etl\")'\n</code></pre> <p>Note that the priorities have switched. The more specific rule has a higher priority, since we want it to be fired first. A query coming from airflow with special label is matched to the \"airflow special\" rule first, since it's higher priority, and the second rule is ignored. A query coming from airflow with no labels does not match the first rule, and is then tested and matched to the second rule.</p> <p>We can also use <code>ConditionalRuleGroup</code> and <code>ActivationRuleGroup</code> to implement an if/else workflow. The following logic in pseudocode:</p> <pre><code>if source == \"airflow\":\n  if clientTags[\"label\"] == \"foo\":\n    return \"etl-foo\"\n  else if clientTags[\"label\"] = \"bar\":\n    return \"etl-bar\"\n  else\n    return \"etl\"\n</code></pre> <p>Can be implemented with these rules:</p> <pre><code>name: \"airflow rule group\"\ndescription: \"routing rules for query from airflow\"\ncompositeRuleType: \"ConditionalRuleGroup\"\ncomposingRules:\n  - name: \"main condition\"\n    description: \"source is airflow\"\n    priority: 0 # rule with the highest priority acts as main condition\n    condition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\n    actions:\n      - \"\"\n  - name: \"airflow subrules\"\n    compositeRuleType: \"ActivationRuleGroup\" # use ActivationRuleGroup to simulate if/else\n    composingRules:\n      - name: \"label foo\"\n        description: \"label client tag is foo\"\n        priority: 0\n        condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=foo\"'\n        actions:\n          - 'result.put(\"routingGroup\", \"etl-foo\")'\n      - name: \"label bar\"\n        description: \"label client tag is bar\"\n        priority: 0\n        condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=bar\"'\n        actions:\n          - 'result.put(\"routingGroup\", \"etl-bar\")'\n      - name: \"airflow default\"\n        description: \"airflow queries default to etl\"\n        condition: \"true\"\n        actions:\n          - 'result.put(\"routingGroup\", \"etl\")'\n</code></pre>"},{"location":"routing-rules/#if-statements-mvel-flow-control","title":"If statements (MVEL Flow Control)","text":"<p>Above, we saw how we can use <code>ConditionalRuleGroup</code> and <code>ActivationRuleGroup</code> to implement and <code>if/else</code> workflow. We could also take advantage of the fact that MVEL supports <code>if</code> statements and other flow control (loops, etc). The following logic in pseudocode:</p> <pre><code>if source == \"airflow\":\n  if clientTags[\"label\"] == \"foo\":\n    return \"etl-foo\"\n  else if clientTags[\"label\"] = \"bar\":\n    return \"etl-bar\"\n  else\n    return \"etl\"\n</code></pre> <p>Can be implemented with these rules:</p> <pre><code>---\nname: \"airflow rules\"\ndescription: \"if query from airflow\"\ncondition: \"request.getHeader(\\\"X-Trino-Source\\\") == \\\"airflow\\\"\"\nactions:\n  - \"if (request.getHeader(\\\"X-Trino-Client-Tags\\\") contains \\\"label=foo\\\") {\n      result.put(\\\"routingGroup\\\", \\\"etl-foo\\\")\n    }\n    else if (request.getHeader(\\\"X-Trino-Client-Tags\\\") contains \\\"label=bar\\\") {\n      result.put(\\\"routingGroup\\\", \\\"etl-bar\\\")\n    }\n    else {\n      result.put(\\\"routingGroup\\\", \\\"etl\\\")\n    }\"\n</code></pre>"},{"location":"security/","title":"Security","text":"<p>Trino Gateway has its own security with its own authentication and authorization. These features are used only to authenticate and authorize its user interface and the APIs. All Trino-related requests are passed through to the Trino cluster without any authentication or authorization check in Trino Gateway.</p>"},{"location":"security/#tls-configuration","title":"TLS configuration","text":"<p>All authentication and authorization mechanisms require configuring TLS as the foundational layer. Your site or cloud environment may already have a load balancer or proxy server configured and running with a valid, globally trusted TLS certificate. In this case, you can work with your network administrators to set up your Trino Gateway behind the load balancer.</p> <p>You can also configure an end-to-end TLS connection using Trino Gateway. This requires you to obtain and install a TLS certificate and configure Trino Gateway to use it for client connections. The following configuration enables TLS for Trino Gateway.</p> <pre><code>serverConfig:\n    http-server.http.enabled: false\n    http-server.https.enabled: true\n    http-server.https.port: 8443\n    http-server.https.keystore.path: certificate.pem\n    http-server.https.keystore.key: changeme\n</code></pre> <p>For advanced configurations, refer to the Trino TLS documentation for more details.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>The authentication would happen on https protocol only. Add the <code>authentication:</code> section in the config file. The default authentication type is set using <code>defaultType: \"form\"</code> Following types of the authentications are supported.</p>"},{"location":"security/#oauthopenidconnect","title":"OAuth/OpenIDConnect","text":"<p>It can be configured as below</p> <pre><code>authentication:\n  defaultType: \"oauth\"\n  oauth:\n    issuer:\n    clientId:\n    clientSecret:\n    tokenEndpoint:\n    authorizationEndpoint:\n    jwkEndpoint:\n    redirectUrl:\n    redirectWebUrl: \n    userIdField:\n    scopes:\n      - s1\n      - s2\n      - s3\n</code></pre> <p>Set the <code>privilegesField</code> to retrieve privileges from an OAuth claim.</p>"},{"location":"security/#note","title":"Note","text":"<ul> <li>For OAuth Trino Gateway uses <code>oidc/callback</code> where as Trino uses <code>oauth2</code> path</li> <li>Trino Gateway should have its own client id</li> <li>All the Trino backend clusters should have a single client id.</li> <li>Trino Gateway needs to pass thorugh the Trino Oauth2 requests only to one of the clusters.</li> <li>One way to handle it is to set a special rule like below: <pre><code>  ---\n  name: \"Oauth requests\"\n  description: \"Oauth requests need to go to a single backed\"\n  condition: \"request.getRequestURI.startsWith(\\\"/oauth2\\\")\"\n  actions:\n    - \"result.put(\\\"routingGroup\\\", \\\"oauth2-handler\\\")\"\n</code></pre></li> <li>That also means you need to have a cluster with that routing group.</li> <li>It's ok to replicate an existing cluster backend record with a different name for that purpose.</li> </ul>"},{"location":"security/#formbasic-authentication","title":"Form/Basic authentication","text":"<p>The authentication happens with the pre-defined users from the configuration file. To define the preset user use the following section. Please note that 'privileges' can only be a combination of 'ADMIN', 'USER', and 'API', with '_' used for segmentation.</p> <pre><code>presetUsers:\n  user1:\n    password: &lt;password&gt;\n    privileges: ADMIN_USER\n  user2:\n    password: &lt;password&gt;\n    privileges: API\n</code></pre> <p>Also provide a random key pair in RSA format.</p> <pre><code>authentication:\n  defaultType: \"form\"\n  form:\n    selfSignKeyPair:\n      privateKeyRsa: &lt;private_key_path&gt;\n      publicKeyRsa: &lt;public_key_path&gt;\n</code></pre>"},{"location":"security/#formldap","title":"Form/LDAP","text":"<p>LDAP requires both random key pair and config path for LDAP</p> <pre><code>authentication:\n  defaultType: \"form\"\n  form:\n    ldapConfigPath: &lt;ldap_config_path&gt;\n    selfSignKeyPair:\n      privateKeyRsa: &lt;private_key_path&gt;\n      publicKeyRsa: &lt;public_key_path&gt;\n</code></pre>"},{"location":"security/#authorization","title":"Authorization","text":"<p>Trino Gateway supports the following roles in regex string format:</p> <ul> <li> <p>admin : Allows access to the Editor tab, which can be used to configure the   backends</p> </li> <li> <p>user : Allows access to the rest of the website</p> </li> <li> <p>api : Allows access to rest apis to configure the backends</p> </li> </ul> <p>Users with attributes next to the role will be giving those privileges the users. You can use the preset users defined in the yaml file.  LDAP Authorization is also supported by adding user attribute configs in file. An OAuth claim can be used by setting the <code>privilegesField</code> in the OAuth configuration.</p> <ul> <li>Check out LDAPTestConfig.yml file for config details</li> </ul> <pre><code># Roles should be in regex format\nauthorization:\n  admin: (.*)ADMIN(.*)\n  user: (.*)USER(.*)\n  api: (.*)API(.*)\n  ldapConfigPath: '&lt;ldap_config_path&gt;'\n</code></pre> <p>The LDAP config file should have the following contents:</p> <pre><code>  ldapHost: '&lt;ldap sever&gt;'\n  ldapPort: &lt;port&gt;\n  useTls: &lt;true/false&gt;\n  useSsl: &lt;true/false&gt;\n  ldapAdminBindDn: &lt;&gt;\n  ldapUserBaseDn: &lt;&gt;\n  ldapUserSearch: &lt;&gt;\n  ldapGroupMemberAttribute: &lt;&gt;\n  ldapAdminPassword: &lt;&gt;\n  ldapTrustStorePath: &lt;for a secure ldap connectivity&gt;\n  ldapTrustStorePassword: '&lt;for a secure ldap connectivity&gt;'\n  poolMaxIdle: 8\n  poolMaxTotal: 8\n  poolMinIdle: 0\n  poolTestOnBorrow: true\n</code></pre>"},{"location":"security/#web-page-permissions","title":"Web page permissions","text":"<p>By default, all pages are accessible to all roles. To limit page access, you can set page permissions by pages  and <code>_</code> as separator field.</p> <p>The following pages are available:</p> <ul> <li><code>dashboard</code></li> <li><code>cluster</code></li> <li><code>resource-group</code></li> <li><code>selector</code></li> <li><code>history</code></li> </ul> <pre><code># admin/api can access all pages, while user can only access dashboard/history\npagePermissions:\n  admin: \n  user: dashboard_history \n  api: \n</code></pre>"},{"location":"security/#extra-self-signed-certificate-in-trino-gateway","title":"Extra: Self-signed certificate in Trino Gateway","text":"<p>If Trino Gateway is using a self-signed certificate, client should use the <code>--insecure</code> config.</p> <pre><code>java -jar trino-cli-executable.jar --server https://localhost:8443 --insecure\n</code></pre>"},{"location":"security/#extra-self-signed-certificate-in-trino","title":"Extra: Self-signed certificate in Trino","text":"<p>If Trino is using a self-signed certificate, the following JVM config for Trino Gateway should be added:</p> <pre><code>-Djavax.net.ssl.trustStore=&lt;truststore file&gt;\n-Djavax.net.ssl.trustStorePassword=&lt;truststore password&gt;\n</code></pre> <p>If you want to skip the hostname validation for a self-signed certificate,  the <code>serverConfig</code> configuration should contain the following:</p> <pre><code>serverConfig:\n  proxy.http-client.https.hostname-verification: false\n  monitor.http-client.https.hostname-verification: false\n</code></pre>"}]}